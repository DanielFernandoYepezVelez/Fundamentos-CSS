        ðŸ‘COMO SABER CUANTAS FILAS O CUANTAS COLUMNAS
                VA A TENER UN LAYOUT A SIMPLE VISTA:
Esta regla funciona tanto para las filas como
para las columnas; SIEMPRE se debe tomar como
referencia el elemento con el tamaÃ±o mas
pequeÃ±o y apartir de ahi, definir cuantas filas
Y/O columnas puede tener dicho LAYOUT.

PROPIEDADES CONTENEDOR PADRE DIRECTAMENTE =>
        ðŸŽ‰FILAS Y COLUMNAS EN GRID
ðŸŽ‰display: grid; => Esta propiedad aplica el
concepto de grillas en todo el layout.
Cuando hablo de grillas, me refiero a filas y a
columnas.

ðŸŽ‰FRACCIÃ“N(1fr) => De todo el espacio que tenga
disponible, lo va a distribuir entre todos los
elementos que existan.

ðŸŽ‰grid-template-columns: 100px 1fr 100px; => Esta 
propiedad dice el nÃºmero de columnas que quiero
establecer.

ðŸŽ‰grid-template-rows: 80px 1fr 150px; => Esta 
propiedad dice el nÃºmero de filas que quiero
establecer.

ðŸŽ‰grid-template: 50% 50% / 1fr 1fr 100px; => Este
es un primer shortHand, que toma primero el numero
de filas y posteriormente el numero de columnas.

ðŸŽ‰grid: 50% 50% / 1fr 1fr 100px; => Este es un
segundo shortHand, que toma primero el numero de
filas y posteriormente el numero de columnas.

ðŸŽ‰grid-gap: 15px; => Esta propiedad aplica un
espaciado entre cada uno de los elementos.

ðŸŽ‰grip-column-gap: 10px; => Esta propiedad aplica un
espaciado entre las columnas del layout.

ðŸŽ‰grip-row-gap: 10px; => Esta propiedad aplica un
espaciado entre las filas del layout.

        ðŸ§¨SE PUEDEN TENER GRIDS DENTRO DE OTROS GRIDS:
ðŸ§¨display: inline-grid; => Crea un grid de una sola
linea(Unidimensional).

ðŸ§¨display: subgrid; => Herada las caracteristicas grid
de su elemento PADRE.

ðŸ§¨ðŸ§¨NOTA => Estas propiedades todavia no estan disponibles.

        ðŸ†NOMBRES A LAS FILAS Y A LAS COLUMNAS:
ðŸ†Darle nombres a las lineas de las filas y de las columnas, nos
ayuda en el momento de hacerlas mas grandes o mas pequeÃ±as,
lo hacemos de la siguiente forma:

ðŸ†grid-template-columns: [lineaColumnaInicio1] 1fr [ColumnaLinea1] 1fr [ColumnaLinea2] 1fr [ColumnaLineaFinal];
ðŸ†grid-template-rows: [lineaInicio1] 1fr [linea1] 1fr [linea2] 1fr [lineaFinal];

             ðŸŽ‰AYUDA DE FIREFOX =>
ðŸŽ‰LINEA CONTINUA => Contiene la grid explicita,
es decir, el numero de filas Y/O columnas que
le indicamos que tenga nuestro Layout.

ðŸŽ‰LINEA DESCONTINUA => Contiene los elementos
que se acomodan de forma implicita, posterior
a las medidas explicitas indicadas. es decir,
estos elementos grid los acomoda, de acuerdo
al espaciado disponible del contenedor PADRE.

ðŸŽ‰LINEA PUNTEADA => ?

ðŸŽ¨TAMAÃ‘OS MINIMOS Y MÃXIMOS PARA LOS ELEMENTOS
ðŸŽ¨minmax(); => Esta propiedad me ayuda mucho para
realizar sitios responsive combinados con media
querys.

ðŸŽ¨grid-template-columns: minmax(300px, 1fr) 1fr; =>
Digo a las columnas que tenga un ancho minimo y
ancho maximo, si el cuenta con el espacio necesario
del elemento padre, el va a tomar el ancho maximo
por defecto, pero el ancho minimo no se disminuye 
menos de lo especificado.

ðŸŽ¨grid-template-rows: minmax(50px, auto) 100px; =>
Digo a las filas que tenga un alto minimo y
alto maximo, si el cuenta con el espacio necesario
del elemento padre, el va a tomar el alto maximo
por defecto, pero el alto minimo no se disminuye 
menos de los especificado.

ðŸŽ¨QUE ES auto =>
ðŸŽ¨AUTO: Cuando le doy un valor a un elemento de auto,
este elemento va a tomar su ancho o alto en layout
dependiendo solamente del tamaÃ±o que abarque su 
contenido interno.

ðŸŽ¨QUE ES maxcontent =>
MAXCONTENT: El contenedor PADRE va a tener un ancho
o un alto maximo del tamaÃ±o de su contenido interno.

ðŸŽ¨NOTA => Tener en cuenta que la funciÃ³n minmax();
funciona para las columnas afectando su ancho y
para las filas afectando su alto.

                ðŸŽ„FUNCIÃ“N repeat();
ðŸŽ„grid-template-columns: repeat(6, minmax(200px, 1fr)); =>
se la puedo aplicar tanto a las columnas como a las 
filas y me ayuda a no tener que repetir los valores
cuando sean iguales, ademÃ¡s de por derla combinar con otras
medidas como piexeles. El primer argumento es el numero
de veces que se debe repetir un valor, y el segundo
argumento es el valor que se debe repetir.

                ðŸŽŠPOSICIONAMIENTO
ðŸŽŠgrid-column-start: 1; | ðŸŽŠgrid-column-start: 2;
ðŸŽŠgrid-column-end: -1;  | ðŸŽŠgrid-column-end: 4;
                ðŸŽŠgrid-column: 2 / 4;
Los elementos empiezan a posicionarse desde una columna
inicial y una columna final, por ende, tambiÃ©n pueden
cambiar su tamaÃ±o, al hacerse mÃ¡s grandes o mÃ¡s pequeÃ±os.
Esta propiedad funciona con nÃºmeros negativos de 
izquierda a derecha y con nÃºmeros positivos de derecha
a izquierda, en este caso para las columnas.

ðŸŽŠgrid-row-start: 1; | ðŸŽŠgrid-row-start: 2;
ðŸŽŠgrid-row-end: -1;  | ðŸŽŠgrid-row-end: 4;
                ðŸŽŠgrid-row: 1 / 3;
Los elementos empiezan a posicionarse desde una fila
inicial y una fila final, por ende, tambiÃ©n pueden
cambiar su tamaÃ±o, al hacerse mÃ¡s grandes o mÃ¡s pequeÃ±os.
Esta propiedad funciona con nÃºmeros negativos de 
izquierda a derecha y con nÃºmeros positivos de derecha
a izquierda, en este caso para las filas.

ðŸŽŠgrid-area: 1 / 2 / 4 / 4; => Esta propiedad alberga
las filas y las columnas en una sola linea y con el 
siguiente orden:
ðŸŽŠgrid-area: grid-row-start / grid-column-start /
                grid-row-end / grid-column-end;

                ðŸŽŠESTIRAR LOS ELEMENTOS =>
ðŸŽŠgrid-column: 2 / span 2; 
ðŸŽŠgrid-column: span 2; 
ðŸŽŠgrid-row: 2 / span 2;
ðŸŽŠgrid-row: span 3;
Estas propiedades le dan un inicio y un fin a un elemento
para que ocupe un espacio en el layout, eso pasa
gracias a la palabra SPAN que indica cuantas columnas o
filas va a tomar un elemento.
Cuando no se tiene un numero inicial se entiende que 
se empieza desde la grid explicita numero UNO.

                ðŸ¥½GRID AREA =>
ðŸ¥½Nos sirven para asignar una secciÃ³n determinada
a un o varios elementos que hacen parte del layout
por medio, de la asignaciÃ³n de clases que ayuden
a identificar la secciÃ³n del layout.
Para dejar un espacio en blanco en la definiciÃ³n
del area agrego un punto(.).

ðŸ¥½NOTA #1 = Los elementos se pueden intercambiar de
lugar en todas las areas que existen en todo el
Layout.

ðŸ¥½NOTA #2 = Cuando trabajo con areas no necesariamente
dejo de definir las filas y columnas de mi LAYOUT.

            ðŸˆALINEACIÃ“N DE ELEMENTOS =>
ðŸˆPROPIEDADES CONTENEDOR PADRE:
ðŸˆAlineando Los Elementos Horizontalmente:
ðŸˆjustify-items: start; => Esta propiedad me ayuda
alinear el elemento al inicio del contenedor.

ðŸˆjustify-items: center; => Esta propiedad me ayuda
alinear el elemento al centro del contenedor.

ðŸˆjustify-items: end; => Esta propiedad me ayuda
alinear el elemento al final del contenedor.

ðŸˆjustify-items: stretch; => Esta propiedad me ayuda
a que el elemento ocupe todo el ancho disponible
del contenedor padre.

Alineando Los Elementos Verticalmente:
ðŸˆalign-items: start; => Esta propiedad me ayuda
alinear el elemento al inicio del contenedor,
pero de forma VERTICAL.

ðŸˆalign-items: center; => Esta propiedad me ayuda
alinear el elemento al centro del contenedor,
pero de forma VERTICAL.

ðŸˆalign-items: end; => Esta propiedad me ayuda
alinear el elemento al final del contenedor,
pero de forma VERTICAL.

ðŸˆalign-items: stretch; => Esta propiedad me ayuda
a que el elemento ocupe todo el ancho disponible
del contenedor padre, pero de forma VERTICAL.

----------------------------------------
ðŸˆPROPIEDAD PARA LOS ELEMENTOS HIJOS: 
ðŸˆAlineando Los Elementos HIJOS Horizontalmente:
ðŸˆjustify-self: start; => Esta propiedad me ayuda
alineando el elemento al inicio del contenedor
PADRE.

ðŸˆjustify-self: center; => Esta propiedad me ayuda
alineando el elemento al centro del contenedor
PADRE.

ðŸˆjustify-self: end; => Esta propiedad me ayuda
alineando el elemento al final del contenedor
PADRE.

ðŸˆjustify-self: stretch; => Esta propiedad me ayuda
a ocupar todo el ancho disponible del contenedor
PADRE.

ðŸˆAlineando Los Elementos HIJOS Verticalmente:
ðŸˆalign-self: start; => Esta propiedad me ayuda
alineando el elemento al inicio del contenedor
PADRE, pero de forma VERTICAL.

ðŸˆalign-self: center; => Esta propiedad me ayuda
alineando el elemento al centro del contenedor
PADRE, pero de forma VERTICAL.

ðŸˆalign-self: end; => Esta propiedad me ayuda
alineando el elemento al final del contenedor
PADRE, pero de forma VERTICAL.

ðŸˆalign-self: stretch; => Esta propiedad me ayuda
a ocupar todo el ancho disponible del contenedor
PADRE, pero de forma VERTICAL.

                ðŸŽ²ALINEACION TRACKS =>
ðŸŽ²Esta propiedad me sirve para alinear todo un bloque
de elementos, tantos de forma de vertical Y
Horizontal de forma interna del contenedor PADRE.

ðŸŽ²Alinear Contenido Horizontalmente:
ðŸŽ²justify-content: normal; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma normal, que es la que se aplica por defecto.

ðŸŽ²justify-content: start; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma inicial del contenedor PADRE.

ðŸŽ²justify-content: center; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma central del contenedor PADRE.

ðŸŽ²justify-content: end; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma final del contenedor PADRE.

ðŸŽ²justify-content: space-around; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos e incluyendo los
bordes.

ðŸŽ²justify-content: space-evenly; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos e incluyendo los
bordes con una medidad igual.

ðŸŽ²justify-content: space-between; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos sin incluir el
espacio de los bordes.

Alinear Contenido Verticalmente:
ðŸŽ²align-content: normal; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma normal, que es la que se aplica por defecto
pero se debe tener encuenta que es de forma
VERTICAL.

ðŸŽ²align-content: start; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma inicial del contenedor PADRE, pero de forma
VERTICAL.

ðŸŽ²align-content: center; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma central del contenedor PADRE, pero de forma
VERTICAL.

ðŸŽ²align-content: end; => Esta propiedad me
ayuda a mantener el bloque de los elementos en su
forma fina del contenedor PADRE, pero de forma
VERTICAL.

ðŸŽ²align-content: space-around; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos e incluyendo los
bordes, pero de formar VERTICAL.

ðŸŽ²align-content: space-between; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos sin incluir el
espacio de los bordes, pero de forma VERTICAL.

ðŸŽ²align-content: space-evenly; => Esta propiedad
me ayuda a mantener el bloque de los elementos con
una separiciÃ³n entre los mismos e incluyendo los
bordes con una medidad igual, pero de forma 
VERTICAL.

                ðŸ’ŽGRID IMPLICITA
ðŸ’ŽSon los elementos que se agregan o distribuyen 
en el layout despues de definir la GRID EXPLICITA.

ðŸ’ŽPROPIEDADES CONTENEDOR PADRE:
ðŸ’Žgrid-auto-flow: row; => Esta Propiedad me cambia la 
direcciÃ³n de mi GRID, por defecto viene para row,
es decir, para filas, en conclusiÃ³n, los
elementos de la grid implicita se van a ir
agregando de forma vertical, hacia abajo.

ðŸ’ŽFilas Automaticas(Implicitas) van a tener un alto de:
grid-auto-rows: 50px 300px 1fr;
El alto se debe definir para el numero de filas que tenga
en la grid implicta.

ðŸ’Žgrid-auto-flow: column; => Esta Propiedad me define
la direccion de la GRID a column, es decir, ya se
van a ir agregando los elementos de forma horizontal,
en conclusiÃ³n, de lado a lado los elementos de la GRID
implicta.

ðŸ’ŽColumnas Automaticas(Implicitas) van a tener un ancho de:
grid-auto-columns: 600px 400px 1fr;
El ancho se debe definir para el numero de columnas que tenga
en la grid implicta.

ðŸ’Žgrid-auto-flow: row dense; => Esta Propiedad Agrega una
distribucion equitativa a los elementos donde exista
un espacio en blanco y contengan las mismas
medidas entre el elemento y la grid. Funciona para
la direccion de row, es decir, de forma VERTICAL.

ðŸ’Žgrid-auto-flow: column dense; => Esta Propiedad Agrega una
distribucion equitativa a los elementos donde exista
un espacio en blanco y contengan las mismas
medidas entre el elemento y la grid. Funciona para
la direccion de column, es decir, de forma 
Horizontal.

ðŸ’ŽSE LE APLICA A LAS PROPIEDADES HIJOS:
ðŸ’ŽAqui estamos expandiendo las columnas y las filas,
y esto nos ayuda con los elementos de la GRID
IMPLICITA.

ðŸ’Žgrid-column: span 2; Este se aplica solo cuando es row dense.
ðŸ’Žgrid-row: span 2; Este se aplica solo cuando es column dense.

                ðŸ¥ŠAUTO-FIT AND AUTO-FILL=>
ðŸ¥Šgrid-template-columns: repeat(auto-fill, minmax(100px, 1fr));

ðŸ¥ŠAUTO-FILL:
Esta Propiedad pone en el contenedor padre
todas las columnas que tenga especificadas  y si en
su ancho disponible le caben mas, ps ese espacio quedara
en blanco, pero cuando el ancho se acabe, se van
a poner de forma vertical, que esto se ve en
dispositivos pequeÃ±os.

ðŸ¥ŠAUTO-FIT:
Esta propiedad tiene el mismo resultado que
auto-fill cuando trabajamos con dispositivos
moviles, la diferencia la notamos con dispositvos
grandes, por que esta propiedad se va a distribuir
en todo el ancho disponible de su contenedor PADRE,
con el numero de columnas que especifiquemos.

ðŸ¥ŠNOTA => No Esta Funcionando Para Filas.